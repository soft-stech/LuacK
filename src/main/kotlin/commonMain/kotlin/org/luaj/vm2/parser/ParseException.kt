/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 5.0 */
/* JavaCCOptions:KEEP_LINE_COL=null */
package org.luaj.vm2.parser

/**
 * This exception is thrown when parse errors are encountered.
 * You can explicitly create objects of this exception type by
 * calling the method generateParseException in the generated
 * parser.
 *
 * You can modify this class to customize your error reporting
 * mechanisms so long as you retain the public fields.
 */
class ParseException : Exception {


    /**
     * This is the last token that has been consumed successfully.  If
     * this object has been created due to a parse error, the token
     * followng this token will (therefore) be the first error token.
     */
    @kotlin.jvm.JvmField
    var currentToken: Token? = null

    /**
     * Each entry in this array is an array of integers.  Each array
     * of integers represents a sequence of tokens (by their ordinal
     * values) that is expected at this point of the parse.
     */
    @kotlin.jvm.JvmField
    var expectedTokenSequences: Array<IntArray>? = null

    /**
     * This is a reference to the "tokenImage" array of the generated
     * parser within which the parse error occurred.  This array is
     * defined in the generated ...Constants interface.
     */
    @kotlin.jvm.JvmField
    var tokenImage: Array<String>? = null

    /**
     * The end of line string for this machine.
     */
    protected var eol = System.getProperty("line.separator", "\n")

    /**
     * This constructor is used by the method "generateParseException"
     * in the generated parser.  Calling this constructor generates
     * a new object of this type with the fields "currentToken",
     * "expectedTokenSequences", and "tokenImage" set.
     */
    constructor(
        currentTokenVal: Token,
        expectedTokenSequencesVal: Array<IntArray>,
        tokenImageVal: Array<String>
    ) : super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal)) {
        currentToken = currentTokenVal
        expectedTokenSequences = expectedTokenSequencesVal
        tokenImage = tokenImageVal
    }

    /**
     * The following constructors are for use by you for whatever
     * purpose you can think of.  Constructing the exception in this
     * manner makes the exception behave in the normal way - i.e., as
     * documented in the class "Throwable".  The fields "errorToken",
     * "expectedTokenSequences", and "tokenImage" do not contain
     * relevant information.  The JavaCC generated code does not use
     * these constructors.
     */

    constructor() : super() {}

    /** Constructor with message.  */
    constructor(message: String) : super(message) {}

    companion object {
        /**
         * It uses "currentToken" and "expectedTokenSequences" to generate a parse
         * error message and returns it.  If this object has been created
         * due to a parse error, and you do not catch it (it gets thrown
         * from the parser) the correct error message
         * gets displayed.
         */
        private fun initialise(
            currentToken: Token,
            expectedTokenSequences: Array<IntArray>,
            tokenImage: Array<String>
        ): String {
            val eol = System.getProperty("line.separator", "\n")
            val expected = StringBuilder()
            var maxSize = 0
            for (i in expectedTokenSequences.indices) {
                if (maxSize < expectedTokenSequences[i].size) {
                    maxSize = expectedTokenSequences[i].size
                }
                for (j in 0 until expectedTokenSequences[i].size) {
                    expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ')
                }
                if (expectedTokenSequences[i][expectedTokenSequences[i].size - 1] != 0) {
                    expected.append("...")
                }
                expected.append(eol).append("    ")
            }
            var retval = "Encountered \""
            var tok = currentToken.next
            for (i in 0 until maxSize) {
                if (i != 0) retval += " "
                if (tok == null || tok.kind == 0) {
                    retval += tokenImage[0]
                    break
                }
                retval += " " + tokenImage[tok.kind]
                retval += " \""
                retval += add_escapes(tok.image!!)
                retval += " \""
                tok = tok.next
            }
            retval += "\" at line " + currentToken.next!!.beginLine + ", column " + currentToken.next!!.beginColumn
            retval += ".$eol"
            if (expectedTokenSequences.size == 1) {
                retval += "Was expecting:$eol    "
            } else {
                retval += "Was expecting one of:$eol    "
            }
            retval += expected.toString()
            return retval
        }

        /**
         * Used to convert raw characters to their escaped version
         * when these raw version cannot be used as part of an ASCII
         * string literal.
         */
        internal fun add_escapes(str: String): String {
            val retval = StringBuilder()
            var ch: Char
            loop@for (i in 0 until str.length) {
                when (str[i]) {
                    '\u0000' -> continue@loop
                    '\b' -> {
                        retval.append("\\b")
                        continue@loop
                    }
                    '\t' -> {
                        retval.append("\\t")
                        continue@loop
                    }
                    '\n' -> {
                        retval.append("\\n")
                        continue@loop
                    }
                    //'\f' -> {
                    '\u000c' -> {
                        retval.append("\\f")
                        continue@loop
                    }
                    '\r' -> {
                        retval.append("\\r")
                        continue@loop
                    }
                    '\"' -> {
                        retval.append("\\\"")
                        continue@loop
                    }
                    '\'' -> {
                        retval.append("\\\'")
                        continue@loop
                    }
                    '\\' -> {
                        retval.append("\\\\")
                        continue@loop
                    }
                    else -> {
                        if (run {
                                ch = str[i]
                                (ch).toInt() < 0x20
                            } || ch.toInt() > 0x7e) {
                            val s = "0000" + ch.toInt().toString(16)
                            retval.append("\\u" + s.substring(s.length - 4, s.length))
                        } else {
                            retval.append(ch)
                        }
                        continue@loop
                    }
                }
            }
            return retval.toString()
        }
    }

}
/* JavaCC - OriginalChecksum=ef246095a930e4915c0d4bbf4c9880ad (do not edit this line) */
